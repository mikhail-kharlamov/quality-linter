[
    {
        "name": "SkipList.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "SkipList/SkipList/SkipList.cs",
        "content": "ï»¿namespace SkipList;\n\nusing System.Collections;\n\n/// <summary>\n/// Class realizes skip list data structure.\n/// </summary>\n/// <typeparam name=\"T\">The type of elements in skip list.</typeparam>\npublic class SkipList<T> : IList<T>\n{\n    private const double PushUpProbability = 0.5;\n    private readonly Comparer<T> comparer;\n    private readonly Random random = new ();\n    private int version;\n    private SkipListNode bottomHead;\n    private SkipListNode topHead;\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"SkipList{T}\"/> class that is empty and has the default comparer for <typeparamref name=\"T\"/>.\n    /// </summary>\n    public SkipList()\n    {\n        bottomHead = new ();\n        topHead = bottomHead;\n        comparer = Comparer<T>.Default;\n    }\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"SkipList{T}\"/> class that is empty and has specified comparer.\n    /// </summary>\n    /// <param name=\"comparer\">Comparer to use for comparing elements.</param>\n    public SkipList(Comparer<T> comparer)\n    : this()\n    {\n        this.comparer = comparer;\n    }\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"SkipList{T}\"/> class that contains elements copied from the specified collection.\n    /// </summary>\n    /// <param name=\"values\">The collection whoose elements are copied to the new skiplist.</param>\n    public SkipList(IEnumerable<T> values)\n    : this()\n    {\n        foreach (var value in values)\n        {\n            this.Add(value);\n        }\n    }\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"SkipList{T}\"/> class that contains elements copied from the specified collection and has specified comparer.\n    /// </summary>\n    /// <param name=\"values\">The collection whoose elements are copied to the new skiplist.</param>\n    /// <param name=\"comparer\">Comparer to use for comparing elements.</param>\n    public SkipList(IEnumerable<T> values, Comparer<T> comparer)\n    : this(values)\n    {\n        this.comparer = comparer;\n    }\n\n    /// <summary>\n    /// Gets the number of elements in the <see cref=\"SkipList{T}\"/>.\n    /// </summary>\n    public int Count { get; private set; }\n\n    /// <summary>\n    /// Gets a value indicating whether the ICollection is read-only.\n    /// </summary>\n    bool ICollection<T>.IsReadOnly => false;\n\n    /// <inheritdoc/>\n    T IList<T>.this[int index]\n    {\n        get => throw new NotSupportedException();\n        set => throw new NotSupportedException();\n    }\n\n    /// <summary>\n    /// <inheritdoc/>\n    /// </summary>\n    /// <returns>An <see cref=\"IEnumerator\"/> that can be used to iterate through the collection.</returns>\n    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n    /// <summary>\n    /// <inheritdoc/>\n    /// </summary>\n    /// <returns>An <see cref=\"IEnumerator{T}\"/> that can be used to iterate through the collection.</returns>\n    public IEnumerator<T> GetEnumerator() => new Enumerator(this);\n\n    /// <summary>\n    /// Adds object to the <see cref=\"SkipList{T}\"/>.\n    /// </summary>\n    /// <param name=\"key\">The object to be added to the end of the <see cref=\"SkipList{T}\"/>.</param>\n    public void Add(T key)\n    {\n        var node = Add(topHead, key);\n        if (node != null)\n        {\n            var newTopHead = new SkipListNode\n            {\n                Down = topHead,\n                Next = new () { Key = key, Down = node },\n            };\n            topHead = newTopHead;\n        }\n\n        ++Count;\n        ++version;\n    }\n\n    /// <inheritdoc/>\n    void IList<T>.Insert(int position, T item) => throw new NotSupportedException();\n\n    /// <summary>\n    /// Removes the first occurrecne of a specific object.\n    /// </summary>\n    /// <param name=\"item\">The object to remove from the <see cref=\"SkipList{T}\"/>.</param>\n    /// <returns>true if item is successfully removed; otherwise false.</returns>\n    public bool Remove(T item)\n    {\n        if (Remove(topHead, item))\n        {\n            --Count;\n            ++version;\n            return true;\n        }\n\n        return false;\n    }\n\n    /// <inheritdoc/>\n    void IList<T>.RemoveAt(int position) => throw new NotSupportedException();\n\n    /// <summary>\n    /// Removes all elements from the <see cref=\"SkipList{T}\"/>.\n    /// </summary>\n    public void Clear()\n    {\n        bottomHead = new ();\n        topHead = bottomHead;\n        ++version;\n        Count = 0;\n    }\n\n    /// <summary>\n    /// Determines whether an element is in the <see cref=\"SkipList{T}\"/>.\n    /// </summary>\n    /// <param name=\"key\">The object to locate in the <see cref=\"SkipList{T}\"/>.</param>\n    /// <returns>true if key is found in the <see cref=\"SkipList{T}\"/>; false otherwise.</returns>\n    public bool Contains(T key)\n    {\n        return Find(topHead, key) != null;\n    }\n\n    /// <summary>\n    /// Searches for the specified object and returns the zero-based index of the first occurrence within the entire <see cref=\"SkipList{T}\"/>.\n    /// </summary>\n    /// <param name=\"key\">The object to locate in the <see cref=\"SkipList{T}\"/>.</param>\n    /// <returns>The zero-based index of the first occurrence of item within the entire <see cref=\"SkipList{T}\"/>, if found; otherwise, -1.</returns>\n    public int IndexOf(T key)\n    {\n        var currentNode = bottomHead;\n        var index = 0;\n        while (currentNode.Next != null && comparer.Compare(currentNode.Next.Key, key) < 0)\n        {\n            currentNode = currentNode.Next;\n            index++;\n        }\n\n        return currentNode.Next != null && comparer.Compare(currentNode.Next.Key, key) == 0 ? index : -1;\n    }\n\n    /// <summary>\n    /// Copies the entire <see cref=\"SkipList{T}\"/> to a compatible one-dimensional array, starting at the specified index of the target array.\n    /// </summary>\n    /// <param name=\"array\">The one-dimensional Array that is the destination of the elements copied from <see cref=\"SkipList{T}\"/>.</param>\n    /// <param name=\"arrayIndex\">The zero-based index in array at which copying begins.</param>\n    /// <exception cref=\"ArgumentException\">Thrown when the number of elements in the <see cref=\"SkipList{T}\"/> is greater than the available space.</exception>\n    /// <exception cref=\"ArgumentNullException\">Thrown when array is null.</exception>\n    /// <exception cref=\"ArgumentOutOfRangeException\">Thrown when arrayIndex is greater than array length or less than zero.</exception>\n    public void CopyTo(T?[] array, int arrayIndex)\n    {\n        ArgumentNullException.ThrowIfNull(array);\n\n        if (arrayIndex < 0 || arrayIndex >= array.Length)\n        {\n            throw new ArgumentOutOfRangeException(nameof(arrayIndex));\n        }\n\n        if (arrayIndex + Count > array.Length)\n        {\n            throw new ArgumentException(\"Not enough space to copy elements\");\n        }\n\n        var currentNode = bottomHead;\n        while (currentNode.Next != null && arrayIndex < array.Length)\n        {\n            array[arrayIndex] = currentNode.Next.Key;\n            currentNode = currentNode.Next;\n            arrayIndex++;\n        }\n    }\n\n    private bool Remove(SkipListNode node, T key)\n    {\n        while (node.Next != null && comparer.Compare(node.Next.Key, key) < 0)\n        {\n            node = node.Next;\n        }\n\n        var result = false;\n        if (node.Down != null)\n        {\n            result |= Remove(node.Down, key);\n        }\n\n        if (node.Next != null && comparer.Compare(node.Next.Key, key) == 0)\n        {\n            node.Next = node.Next.Next;\n            return true;\n        }\n\n        return result;\n    }\n\n    private SkipListNode? Add(SkipListNode node, T key)\n    {\n        while (node.Next != null && comparer.Compare(node.Next.Key, key) < 0)\n        {\n            node = node.Next;\n        }\n\n        var downNode = node.Down == null ? null : Add(node.Down, key);\n\n        if (downNode != null || node.Down == null)\n        {\n            node.Next = new () { Next = node.Next, Down = downNode, Key = key };\n            if (random.NextDouble() < PushUpProbability)\n            {\n                return node.Next;\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        return null;\n    }\n\n    private SkipListNode? Find(SkipListNode node, T key)\n    {\n        while (node.Next != null && comparer.Compare(node.Next.Key, key) < 0)\n        {\n            node = node.Next;\n        }\n\n        if (node.Next != null && comparer.Compare(node.Next.Key, key) == 0)\n        {\n            return node;\n        }\n        else\n        {\n            return node.Down == null ? null : Find(node.Down, key);\n        }\n    }\n\n    /// <summary>\n    /// Enumerates the elements of the <see cref=\"SkipList{t}\"/>.\n    /// </summary>\n    private struct Enumerator : IEnumerator<T>\n    {\n        private readonly SkipList<T> skipList;\n        private readonly int version;\n        private SkipListNode current;\n        private bool isHead;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"SkipList{T}.Enumerator\"/> struct.\n        /// </summary>\n        /// <param name=\"skiplist\">SkipList to enumerate.</param>\n        public Enumerator(SkipList<T> skiplist)\n        {\n            this.skipList = skiplist;\n            version = skiplist.version;\n            current = skipList.bottomHead;\n            isHead = true;\n        }\n\n        /// <summary>\n        /// Gets the element at the current position of the enumerator.\n        /// </summary>\n        public T Current\n        {\n            get\n            {\n                if (version != skipList.version)\n                {\n                    throw new InvalidOperationException(\"Invalid iterator\");\n                }\n\n                if (isHead)\n                {\n                    throw new InvalidOperationException(\"Current position is before first element\");\n                }\n\n                if (current.Key == null)\n                {\n                    throw new InvalidOperationException(\"Current node value is null\");\n                }\n\n                return current.Key;\n            }\n        }\n\n        /// <summary>\n        /// Gets the element at the current position of the enumerator.\n        /// </summary>\n        object IEnumerator.Current => Current!;\n\n        /// <summary>\n        /// <inheritdoc/>\n        /// </summary>\n        public readonly void Dispose()\n        {\n        }\n\n        /// <summary>\n        /// Advances enumerator to the next element of the <see cref=\"SkipList{T}\"/>.\n        /// </summary>\n        /// <returns>true if succsessfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>\n        /// <exception cref=\"InvalidOperationException\">Thrown if collection was modified after creating enumerator.</exception>\n        public bool MoveNext()\n        {\n            if (version != skipList.version)\n            {\n                throw new InvalidOperationException(\"Invalid iterator\");\n            }\n\n            if (current.Next != null)\n            {\n                current = current.Next;\n                isHead = false;\n                return true;\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Sets the enumerator to its initial position.\n        /// </summary>\n        /// <exception cref=\"InvalidOperationException\">Thrown if collection was modified after creating enumerator.</exception>\n        public void Reset()\n        {\n            if (version != skipList.version)\n            {\n                throw new InvalidOperationException(\"Invalid iterator\");\n            }\n\n            current = skipList.bottomHead;\n            isHead = true;\n        }\n    }\n\n    private class SkipListNode\n    {\n        public SkipListNode? Next { get; set; }\n\n        public SkipListNode? Down { get; set; }\n\n        public T? Key { get; set; }\n    }\n}\n"
    },
    {
        "name": "SkipListTests.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "SkipList/SkipListTests/SkipListTests.cs",
        "content": "namespace SkipList.Tests;\r\n\r\npublic class Tests\r\n{\r\n    [Test]\r\n    public void Contains_OneElement_ReturnsExpectedResult()\r\n    {\r\n        var skipList = new SkipList<int>();\r\n        skipList.Add(1);\r\n        Assert.That(skipList.Contains(1), Is.True);\r\n        Assert.That(skipList.Contains(2), Is.False);\r\n    }\r\n\r\n    [Test]\r\n    public void Constructor_FromListOfIntsWithDefaultComparer_ContainsEveryElemFromList()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        var skipList = new SkipList<int>(list); \r\n        Assert.That(skipList.Count, Is.EqualTo(6));\r\n        foreach (var elem in list)\r\n        {\r\n            Assert.That(skipList.Contains(elem), Is.True);\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void Add_IntsToEmptySKipList_ContainsEveryAddedElement()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        var skipList = new SkipList<int> ();\r\n        foreach (var elem in list)\r\n        {\r\n            skipList.Add(elem);\r\n        }\r\n\r\n        Assert.That(skipList.Count, Is.EqualTo(6));\r\n        \r\n        foreach (var elem in list)\r\n        {\r\n            Assert.That(skipList.Contains(elem), Is.True, $\"elem is {elem}\");\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void Remove_OneElement_DoesNotContainRemovedElement()\r\n    {\r\n        var skipList = new SkipList<int>([1, 2, 1000, 100, -1, 0]); \r\n        skipList.Remove(0);\r\n        Assert.That(skipList.Contains(0), Is.False);\r\n    }\r\n\r\n    [Test]\r\n    public void Clear_NotEmptySkipList_DoesNotContainElements()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        var skipList = new SkipList<int> (list);\r\n        skipList.Clear();\r\n\r\n        Assert.That(skipList.Count, Is.EqualTo(0));\r\n\r\n        foreach (var elem in list)\r\n        {\r\n            Assert.That(skipList.Contains(elem), Is.False);\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void IndexOf_ElementInSkipList_ReturnsExpectedValue()\r\n    {\r\n        var skipList = new SkipList<int>([1, 2, 1000, 100, -1, 0]); \r\n        Assert.That(skipList.IndexOf(-1), Is.EqualTo(0), $\"Contain? {skipList.Contains(-1)}\");\r\n        Assert.That(skipList.IndexOf(0), Is.EqualTo(1));\r\n        Assert.That(skipList.IndexOf(1000), Is.EqualTo(5));\r\n    }\r\n\r\n    [Test]\r\n    public void CopyTo_ArrayHasEnoughSpace_ArrayContainsEveryCopiedElement()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        list.Sort();\r\n        var skipList = new SkipList<int> (list);\r\n        var array = new int[6];\r\n        skipList.CopyTo(array, 0);\r\n        for (int i = 0; i < 6; ++i)\r\n        {\r\n            Assert.That(array[i], Is.EqualTo(list[i]));\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void Enumerator_TryUsingAreEqual_ShouldPassTest()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        var skipList = new SkipList<int>(list);\r\n        list.Sort();\r\n        CollectionAssert.AreEqual(skipList, list);\r\n    }\r\n\r\n    [Test]\r\n    public void Enumerator_InsideForeach()\r\n    {\r\n        var list = new List<int> { 1, 2, 1000, 100, -1, 0 };\r\n        var skipList = new SkipList<int>(list);\r\n        var actual = new List<int>();\r\n        foreach (var item in skipList)\r\n        {\r\n            actual.Add(item);\r\n        }\r\n        list.Sort();\r\n        CollectionAssert.AreEqual(actual, list);\r\n    }\r\n\r\n    [Test]\r\n    public void Enumerator_ChangeCollectionAfterCreatingEnumerator_ThrowsInvalidOperationException()\r\n    {\r\n        var skipList = new SkipList<int>([1, 2, 1000, 100, -1, 0]); \r\n        var enumerator = skipList.GetEnumerator();\r\n        enumerator.MoveNext();\r\n        skipList.Add(1);\r\n        Assert.Throws<InvalidOperationException>(() => enumerator.MoveNext());\r\n        Assert.Throws<InvalidOperationException>(() => enumerator.Reset());\r\n    }\r\n}"
    }
]