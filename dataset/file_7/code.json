[
    {
        "name": "MyThreadPool.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "MyThreadPool/MyThreadPool/MyThreadPool.cs",
        "content": "ï»¿// Copyright (c) 2024\n//\n// Use of this source code is governed by an MIT license\n// that can be found in the LICENSE file or at\n// https://opensource.org/licenses/MIT.\n\nnamespace MyThreadPool;\n\nusing System.Collections.Concurrent;\n\n/// <summary>\n/// Provides a pool of threads that can be used to execute tasks asynchronously.\n/// </summary>\npublic class MyThreadPool : IDisposable\n{\n    private readonly ConcurrentQueue<Action> tasks = new ();\n    private readonly Thread[] threads;\n    private readonly CancellationTokenSource cancellationTokenSource = new ();\n    private readonly ManualResetEvent shutdownEvent = new (true);\n    private readonly AutoResetEvent wakeUpEvent = new (false);\n    private readonly ManualResetEvent cancelEvent = new (false);\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"MyThreadPool\"/> class with specified number of running threads.\n    /// </summary>\n    /// <param name=\"numberOfThreads\">Number of threads to be created inside MyThreadPool class.</param>\n    public MyThreadPool(int numberOfThreads)\n    {\n        if (numberOfThreads < 1)\n        {\n            throw new ArgumentException(\"number of threads must be postive number!\", nameof(numberOfThreads));\n        }\n\n        this.ThreadsCount = numberOfThreads;\n        this.threads = new Thread[this.ThreadsCount];\n        for (var i = 0; i < this.ThreadsCount; ++i)\n        {\n            this.threads[i] = new (this.Worker);\n        }\n\n        foreach (var thread in this.threads)\n        {\n            thread.Start();\n        }\n    }\n\n    /// <summary>\n    /// Gets the number of threads that are currently running.\n    /// </summary>\n    public int ThreadsCount { get; private set; }\n\n    /// <summary>\n    /// Shuts down treadpool. All tasks that were submitted before shutdown will be completed.\n    /// </summary>\n    public void Shutdown()\n    {\n        lock (this.tasks)\n        {\n            if (this.cancellationTokenSource.IsCancellationRequested)\n            {\n                return;\n            }\n\n            this.cancellationTokenSource.Cancel();\n\n            this.cancelEvent.Set();\n            for (var i = 0; i < this.ThreadsCount; ++i)\n            {\n                this.threads[i].Join();\n            }\n        }\n    }\n\n    public void Dispose()\n    {\n        this.Shutdown();\n\n        this.shutdownEvent.Dispose();\n        this.wakeUpEvent.Dispose();\n        this.cancelEvent.Dispose();\n    }\n\n    /// <summary>\n    /// Queues the specified function to evaluate on the <see cref=\"MyThreadPool\"/> and returns a <see cref=\"IMyTask<typeparamref name=\"T\"/>\"/> for that function.\n    /// </summary>\n    /// <typeparam name=\"T\">Type of the result of the evaluation.</typeparam>\n    /// <param name=\"task\">Functions to evaluate on <see cref=\"MyThreadPool\"/>.</param>\n    /// <returns><see cref=\"IMyTask\"/> for the given function.</returns>\n    public IMyTask<T> Submit<T>(Func<T> task)\n    {\n        if (this.cancellationTokenSource.IsCancellationRequested)\n        {\n            throw new OperationCanceledException(\"Threadpool was shut down!\");\n        }\n\n        lock (this.tasks)\n        {\n            if (this.cancellationTokenSource.IsCancellationRequested)\n            {\n                throw new OperationCanceledException(\"Threadpool was shut down!\");\n            }\n\n            var newMyTask = new MyTask<T>(this, task, this.cancellationTokenSource.Token, this.shutdownEvent);\n            this.tasks.Enqueue(newMyTask.Start);\n            this.wakeUpEvent.Set();\n\n            return newMyTask;\n        }\n    }\n\n    private void Worker()\n    {\n        while (!this.cancellationTokenSource.IsCancellationRequested)\n        {\n            WaitHandle.WaitAny([this.wakeUpEvent, this.cancelEvent]);\n            if (this.tasks.TryDequeue(out var task))\n            {\n                this.wakeUpEvent.Set();\n                task();\n            }\n        }\n    }\n\n    private class MyTask<TResult>(MyThreadPool threadPool, Func<TResult> func, CancellationToken cancellationToken, ManualResetEvent shutdownEvent) : IMyTask<TResult>\n    {\n        private readonly Func<TResult> func = func;\n        private readonly object lockObject = new ();\n        private readonly ManualResetEvent shutdownEvent = shutdownEvent;\n        private readonly Queue<Action> continueWithTasks = new ();\n        private readonly MyThreadPool threadPool = threadPool;\n        private readonly CancellationToken cancellationToken = cancellationToken;\n        private AggregateException? aggregateException;\n        private TResult? result;\n\n        public TResult? Result\n        {\n            get\n            {\n                if (!this.IsCompleted)\n                {\n                    if (this.cancellationToken.IsCancellationRequested)\n                    {\n                        throw new OperationCanceledException(\"Thread pool was shut down!\");\n                    }\n\n                    this.Start();\n                }\n\n                if (this.aggregateException != null)\n                {\n                    throw this.aggregateException;\n                }\n\n                return this.result;\n            }\n            private set => this.result = value;\n        }\n\n        public bool IsCompleted { get; private set; }\n\n        public IMyTask<TNewResult> ContinueWith<TNewResult>(Func<TResult?, TNewResult?> func)\n        {\n            lock (this.threadPool.tasks)\n            {\n                if (this.cancellationToken.IsCancellationRequested)\n                {\n                    throw new OperationCanceledException(\"Threadpool was shut down!\");\n                }\n\n                var newFunc = () => func(this.Result);\n                if (this.IsCompleted)\n                {\n                    return this.threadPool.Submit(newFunc);\n                }\n\n                var newMyTask = new MyTask<TNewResult>(this.threadPool, newFunc, this.cancellationToken, this.shutdownEvent) as IMyTask<TNewResult>;\n                this.continueWithTasks.Enqueue(() => this.threadPool.Submit(() => newMyTask.Result));\n\n                return newMyTask;\n            }\n        }\n\n        public void Start()\n        {\n            if (this.IsCompleted)\n            {\n                return;\n            }\n\n            lock (this.lockObject)\n            {\n                if (!this.IsCompleted)\n                {\n                    try\n                    {\n                        this.Result = this.func();\n                    }\n                    catch (Exception e)\n                    {\n                        this.aggregateException = new (\"Task failed\", e);\n                    }\n                    finally\n                    {\n                        this.IsCompleted = true;\n                        while (this.continueWithTasks.Count > 0)\n                        {\n                            if (this.continueWithTasks.TryDequeue(out var continueWithTask))\n                            {\n                                try\n                                {\n                                    continueWithTask();\n                                }\n                                catch (OperationCanceledException)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "name": "MyThreadPoolTests.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "MyThreadPool/MyThreadPoolTests/MyThreadPoolTests.cs",
        "content": "// Copyright (c) 2024\r\n//\r\n// Use of this source code is governed by an MIT license\r\n// that can be found in the LICENSE file or at\r\n// https://opensource.org/licenses/MIT.\r\n\r\nnamespace MyThreadPool.Tests;\r\n\r\npublic class Tests\r\n{\r\n    private static readonly int numberOfThreads = 10;\r\n    private MyThreadPool threadPool = new(numberOfThreads);\r\n\r\n    [SetUp]\r\n    public void Setup()\r\n    {\r\n        threadPool = new(numberOfThreads);\r\n    }\r\n\r\n    [Test]\r\n    [TestCase(1)]\r\n    [TestCase(10)]\r\n    [TestCase(20)]\r\n    public void CheckIfThereIsExactlyNThreadsInPool(int n)\r\n    {\r\n        HashSet<Thread?> threads = [];\r\n        threadPool = new(n);\r\n        List<IMyTask<Thread>> tasks = [];\r\n        ManualResetEvent manualResetEvent = new(false);\r\n        for (var i = 0; i < 2 * n; ++i)\r\n        {\r\n            tasks.Add(threadPool.Submit(() =>\r\n            {\r\n                manualResetEvent.WaitOne();\r\n                return Thread.CurrentThread;\r\n            }));\r\n        }\r\n        manualResetEvent.Set();\r\n        Thread.Sleep(100);\r\n        threadPool.Shutdown();\r\n        foreach (var task in tasks)\r\n        {\r\n            threads.Add(task.Result);\r\n        }\r\n        Assert.That(threads, Has.Count.EqualTo(n));\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitSimpleTaskReturnsExpectedResult()\r\n    {\r\n        var expected = 1;\r\n        var task = threadPool.Submit(() => expected);\r\n        Assert.That(task.Result, Is.EqualTo(expected));\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitMultipleTasksReturnsExpectedResult()\r\n    {\r\n        List<IMyTask<int>> tasks = [];\r\n        for (var i = 0; i < threadPool.ThreadsCount; ++i)\r\n        {\r\n            var localI = i;\r\n            var task = threadPool.Submit(() =>\r\n            {\r\n                return localI;\r\n            });\r\n            tasks.Add(task);\r\n        }\r\n        Thread.Sleep(100);\r\n        for (var i = 0; i < threadPool.ThreadsCount; ++i)\r\n        {\r\n            Assert.That(tasks[i].Result, Is.EqualTo(i));\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitTaskWithOneContinueTasksReturnsExpectedResult()\r\n    {\r\n        var task = threadPool.Submit(() => \"1\").ContinueWith(x => int.Parse(x!));\r\n        Assert.That(task.Result, Is.EqualTo(1));\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitTaskWithMultipleContinueTasksReturnsExpectedResult()\r\n    {\r\n        List<IMyTask<int>> tasks = [];\r\n        var task = threadPool.Submit(() => 2);\r\n        for (var i = 0; i < threadPool.ThreadsCount; ++i)\r\n        {\r\n            var localI = i;\r\n            var continueTask = task.ContinueWith(x => localI * x);\r\n            tasks.Add(continueTask);\r\n        }\r\n        Thread.Sleep(100);\r\n        for (var i = 0; i < threadPool.ThreadsCount; ++i)\r\n        {\r\n            Assert.That(tasks[i].Result, Is.EqualTo(2 * i));\r\n        }\r\n\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitTaskWithChainedContinueTasksReturnsExpectedResult()\r\n    {\r\n        var task = threadPool.Submit(() => \"1\").ContinueWith(x => int.Parse(x!)).ContinueWith(x => 2 * x + 1);\r\n        Thread.Sleep(50);\r\n        var expected = 3;\r\n        Assert.That(task.Result, Is.EqualTo(expected));\r\n    }\r\n\r\n    [Test]\r\n    public void ResultFuncThrowsExceptionShouldThrowAgregateException()\r\n    {\r\n        var task = threadPool.Submit<int>(() => throw new DivideByZeroException());\r\n        Assert.Throws<AggregateException>(() => { var result = task.Result; });\r\n    }\r\n\r\n    [Test]\r\n    public void TasksSubmitedBerforeShutdownAreCompletedAfterShutdown()\r\n    {\r\n        List<IMyTask<int>> tasks = new();\r\n        for (var i = 0; i < 2 * threadPool.ThreadsCount; ++i)\r\n        {\r\n            threadPool.Submit(() =>\r\n            {\r\n                Thread.Sleep(100);\r\n                return 1;\r\n            });\r\n        }\r\n        threadPool.Shutdown();\r\n        foreach (var task in tasks)\r\n        {\r\n            Assert.That(task.IsCompleted, Is.True);\r\n        }\r\n    }\r\n\r\n    [Test]\r\n    public void SubmitAndContinueWithFromMultipleThreadsPerformsExpectedResults()\r\n    {\r\n        var expected = 10;\r\n        var threadsCount = 6;\r\n        var actual = new IMyTask<int>[threadsCount];\r\n        var threads = new Thread[threadsCount];\r\n        var manualResetEvent = new ManualResetEvent(false);\r\n\r\n        for (var i = 0; i < threadsCount; ++i)\r\n        {\r\n            var localI = i;\r\n            threads[i] = new(() =>\r\n            {\r\n                manualResetEvent.WaitOne();\r\n\r\n                actual[localI] = threadPool.Submit(() => 5).ContinueWith(r => 2 * r);\r\n            });\r\n        }\r\n\r\n        foreach (var thread in threads)\r\n        {\r\n            thread.Start();\r\n        }\r\n\r\n        manualResetEvent.Set();\r\n\r\n        foreach (var thread in threads)\r\n        {\r\n            thread.Join();\r\n        }\r\n\r\n        Assert.That(actual.All(r => r.Result == expected), Is.True);\r\n    }\r\n\r\n    [Test]\r\n    public async Task SubmitAndShutdownFromMultipleThreadsPerformsExpectedResults()\r\n    {\r\n        var manualResetEvent = new ManualResetEvent(false);\r\n        var expected = 50 * 101;\r\n        var actual = 0;\r\n\r\n        var submitTask = Task.Run(() =>\r\n        {\r\n            manualResetEvent.WaitOne();\r\n            return threadPool.Submit(() => Enumerable.Range(1, 100).Sum());\r\n        });\r\n\r\n        var firstShutdown = Task.Run(() =>\r\n        {\r\n            manualResetEvent.WaitOne();\r\n            threadPool.Shutdown();\r\n        });\r\n\r\n        var secondShutdown = Task.Run(() =>\r\n        {\r\n            manualResetEvent.WaitOne();\r\n            threadPool.Shutdown();\r\n        });\r\n\r\n        manualResetEvent.Set();\r\n\r\n        try\r\n        {\r\n            actual = (await submitTask).Result;\r\n        }\r\n        catch (OperationCanceledException)\r\n        {\r\n            Assert.Pass();\r\n        }\r\n\r\n        Assert.That(actual, Is.EqualTo(expected));\r\n    }\r\n}"
    }
]