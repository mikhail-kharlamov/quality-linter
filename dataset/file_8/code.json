[
    {
        "name": "MultiThreadLazy.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "Lazy/Lazy/MultiThreadLazy.cs",
        "content": "// Copyright (c) 2024\n//\n// Use of this source code is governed by an MIT license\n// that can be found in the LICENSE file or at\n// https://opensource.org/licenses/MIT.\n\nnamespace Lazy;\n\n/// <summary>\n/// Implements Multi-thread lazy evaluation.\n/// </summary>\n/// <typeparam name=\"T\">Type of the result of evalution.</typeparam>\n/// <param name=\"supplier\">Function to evaluate.</param>\npublic class MultiThreadLazy<T>(Func<T> supplier) : ILazy<T>\n{\n    private readonly Semaphore semaphore = new (1, 1);\n    private Func<T>? supplier = supplier;\n    private T? result;\n    private Exception? exception;\n\n    private bool isReady;\n\n    /// <inheritdoc/>\n    public T? Get()\n    {\n        if (this.exception != null)\n        {\n            throw this.exception;\n        }\n\n        if (!this.isReady)\n        {\n            this.semaphore.WaitOne();\n            if (!this.isReady)\n            {\n                try\n                {\n                    if (this.supplier is null)\n                    {\n                        throw new InvalidOperationException(\"Supplier is null\");\n                    }\n\n                    this.result = this.supplier();\n                }\n                catch (Exception e)\n                {\n                    this.exception = e;\n                    throw;\n                }\n                finally\n                {\n                    this.supplier = null;\n                    this.isReady = true;\n                    this.semaphore.Release();\n                }\n            }\n            else\n            {\n                this.semaphore.Release();\n            }\n        }\n\n        return this.result;\n    }\n}\n"
    },
    {
        "name": "SingleThreadLazy.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "Lazy/Lazy/SingleThreadLazy.cs",
        "content": "// Copyright (c) 2024\n//\n// Use of this source code is governed by an MIT license\n// that can be found in the LICENSE file or at\n// https://opensource.org/licenses/MIT.\n\nnamespace Lazy;\n\n/// <summary>\n/// Implements single-thread lazy evaluation.\n/// </summary>\n/// <typeparam name=\"T\">Type of the result of evaluation.</typeparam>\n/// <param name=\"supplier\">Funciton to evaluate.</param>\npublic class SingleThreadLazy<T>(Func<T> supplier) : ILazy<T>\n{\n    private Func<T>? supplier = supplier;\n    private T? result;\n    private bool isReady;\n    private Exception? exception;\n\n    /// <inheritdoc/>\n    public T? Get()\n    {\n        if (!this.isReady)\n        {\n            try\n            {\n                if (this.supplier is null)\n                {\n                    throw new InvalidOperationException(\"Supplier is null!\");\n                }\n\n                this.result = this.supplier();\n            }\n            catch (Exception e)\n            {\n                this.exception = e;\n                throw;\n            }\n            finally\n            {\n                this.supplier = null;\n                this.isReady = true;\n            }\n        }\n\n        return this.result;\n    }\n}\n"
    },
    {
        "name": "LazyTests.cs",
        "extension": "cs",
        "is_binary": false,
        "path": "Lazy/LazyTests/LazyTests.cs",
        "content": "// <copyright file=\"LazyTests.cs\" company=\"PlaceholderCompany\">\r\n// Copyright (c) PlaceholderCompany. All rights reserved.\r\n// </copyright>\r\n\r\nnamespace Lazy.Tests;\r\n\r\npublic class Tests\r\n{\r\n    private static int supplierRunsCounter = 1;\r\n\r\n    private static int expectedValue = 100;\r\n\r\n    private static IEnumerable<TestCaseData> Lazies()\r\n    {\r\n        yield return new TestCaseData(new SingleThreadLazy<int>(() => expectedValue));\r\n        yield return new TestCaseData(new MultiThreadLazy<int>(() => expectedValue));\r\n    }\r\n\r\n    private static IEnumerable<TestCaseData> LaziesCountRuns()\r\n    {\r\n        yield return new TestCaseData(new SingleThreadLazy<int>(() => supplierRunsCounter++));\r\n        yield return new TestCaseData(new MultiThreadLazy<int>(() => supplierRunsCounter++));\r\n    }\r\n\r\n    private static IEnumerable<TestCaseData> LaziesThrowException()\r\n    {\r\n        Func<int> supplier = () =>\r\n        {\r\n            return 1 / (Environment.ProcessId - Environment.ProcessId);\r\n        };\r\n\r\n        yield return new TestCaseData(new SingleThreadLazy<int>(supplier));\r\n        yield return new TestCaseData(new MultiThreadLazy<int>(supplier));\r\n    }\r\n\r\n    [TestCaseSource(nameof(Lazies))]\r\n    public void GetShouldReturnExpectedValue(ILazy<int> lazy)\r\n    {\r\n        Assert.That(lazy.Get(), Is.EqualTo(expectedValue));\r\n    }\r\n\r\n    [TestCaseSource(nameof(LaziesCountRuns))]\r\n    public void GetSeveralTimesSupplierShouldBeCalledOnce(ILazy<int> lazy)\r\n    {\r\n        var firstRun = lazy.Get();\r\n        var secondRun = lazy.Get();\r\n        var thirdRun = lazy.Get();\r\n        Assert.Multiple(() =>\r\n        {\r\n            Assert.That(firstRun, Is.EqualTo(secondRun));\r\n            Assert.That(secondRun, Is.EqualTo(thirdRun));\r\n        });\r\n    }\r\n\r\n    [TestCaseSource(nameof(LaziesThrowException))]\r\n    public void GetSupplierThrowsExceptionShouldRethrowThatException(ILazy<int> lazy)\r\n    {\r\n        Assert.Throws<DivideByZeroException>(() => lazy.Get());\r\n    }\r\n\r\n    [Test]\r\n    public void GetMultiThreadShouldReturnCorrectValue()\r\n    {\r\n        var expectedResult = 10;\r\n        var initial = 0;\r\n        MultiThreadLazy<int> lazy = new (() => initial += 10);\r\n        var numberOfThreads = 10;\r\n        var threads = new Thread[numberOfThreads];\r\n        var results = new int[numberOfThreads];\r\n        var manualResetEvent = new ManualResetEvent(false);\r\n        for (int i = 0; i < threads.Length; ++i)\r\n        {\r\n            var localI = i;\r\n            threads[i] = new (() => {\r\n                manualResetEvent.WaitOne();\r\n                results[localI] = lazy.Get();\r\n            });\r\n        }\r\n\r\n        foreach (var thread in threads)\r\n        {\r\n            thread.Start();\r\n        }\r\n\r\n        manualResetEvent.Set();\r\n\r\n        foreach (var thread in threads)\r\n        {\r\n            thread.Join();\r\n        }\r\n\r\n        Assert.That(results.All(x => x == expectedResult), Is.True);\r\n    }\r\n}"
    }
]